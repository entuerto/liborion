--
-- gnumake.lua
-- liborion configuration file.
-- Copyright (c) 2016 Tomas Palazuelos
--

premake.gnumake = {}

local p = premake
local gnumake = p.gnumake
local project = p.project
local config  = p.config
local fileconfig = p.fileconfig

p.gnumake.cpp   = {}
local cpp = p.gnumake.cpp

---
-- The GNU make action, with support for the new platforms API
---

newaction 
{
   trigger         = "gnumake",
   shortname       = "GNU Make",
   description     = "Generate GNU makefiles for POSIX, MinGW",

   valid_kinds     = { "ConsoleApp", "WindowedApp", "StaticLib", "SharedLib", "Utility", "Makefile" },

   valid_languages = { "C", "C++" },

   valid_tools     = {
      cc = { "clangcl", "clang", "gcc" }
   },

   onStart = function()
      print("onStart()")

      gnumake.cpp.initialize()
   end,

   onWorkspace = function(wks)
      print("onWorkspace(" .. wks.name ..")")

      p.escaper(gnumake.esc)

      p.generate(wks, gnumake.getMakefileName(wks, false), gnumake.generateWorkspace)
   end,

   onProject = function(prj)
      print("onProject(" .. prj.name ..")")

      p.escaper(gnumake.esc)

      local makefile = gnumake.getMakefileName(prj, true)
--
--      if prj.kind == p.UTILITY then
--         p.generate(prj, makefile, make.utility.generate)
--      elseif prj.kind == p.MAKEFILE then
--         p.generate(prj, makefile, make.makefile.generate)
--      else
--         if project.isdotnet(prj) then
--            p.generate(prj, makefile, make.cs.generate)
--         elseif project.iscpp(prj) then
--            p.generate(prj, makefile, make.cpp.generate)
--         end
--      end
      if project.iscpp(prj) then
         p.generate(prj, makefile, gnumake.cpp.generate)
      end
   end,

   onRule = function(rule)
      print("onRule(" .. rule.name ..")")
   end,

   onCleanWorkspace = function(wks)
      print("onCleanWorkspace(" .. wks.name ..")")

      p.clean.file(wks, gnumake.getMakefileName(wks, false))
   end,

   onCleanProject = function(prj)
      print("onCleanProject(" .. prj.name ..")")

      p.clean.file(prj, gnumake.getMakefileName(prj, true))
   end
}

---
-- Escape a string so it can be written to a makefile.
---
function gnumake.esc(value)
   result = value:gsub("\\", "\\\\")
   result = result:gsub("\"", "\\\"")
   result = result:gsub(" ", "\\ ")
   result = result:gsub("%(", "\\(")
   result = result:gsub("%)", "\\)")

   -- leave $(...) shell replacement sequences alone
   result = result:gsub("$\\%((.-)\\%)", "$(%1)")
   return result
end

--
-- Get the makefile file name for a workspace or a project. If this object is the
-- only one writing to a location then I can use "Makefile". If more than one object
-- writes to the same location I use name + ".make" to keep it unique.
--
function gnumake.getMakefileName(this, searchprjs)
   local count = 0

   for wks in p.global.eachWorkspace() do
      if wks.location == this.location then
         count = count + 1
      end

      if searchprjs then
         for _, prj in ipairs(wks.projects) do
            if prj.location == this.location then
               count = count + 1
            end
         end
      end
   end

   return iif(count == 1, "Makefile", ".make")
end

--
-- Write out the default configuration rule for a workspace or project.
--
-- @param target
--    The workspace or project object for which a makefile is being generated.
--
function gnumake.defaultConfig(target)
   -- find the right configuration iterator function for this object
   local eachconfig = iif(target.project, project.eachconfig, p.workspace.eachconfig)
   local iter = eachconfig(target)

   -- grab the first configuration and write the block
   local cfg = iter()
   if cfg then
      _p('ifndef config')
      _x('  config=%s', cfg.shortname)
      _p('endif')
      _p('')
   end
end

--
-- Output a makefile header.
--
-- @param target
--    The workspace or project object for which the makefile is being generated.
--
function gnumake.header(target)
   local kind = iif(target.project, "project", "workspace")

   _p('# %s %s makefile autogenerated by Premake', p.action.current().shortname, kind)
   _p('')

   if kind == "workspace" then
      _p('.NOTPARALLEL:')
      _p('')
   end

   gnumake.defaultConfig(target)

   _p('ifndef verbose')
   _p('  SILENT = @')
   _p('endif')
   _p('')
end

--
-- Rules for file ops based on the shell type. Can't use defines and $@ because
-- it screws up the escaping of spaces and parethesis (anyone know a fix?)
--
function gnumake.mkdirRules(dirname)
   _p('%s:', dirname)
   _p('\t@echo Creating %s', dirname)
   _p('ifeq (posix,$(SHELLTYPE))')
   _p('\t$(SILENT) mkdir -p %s', dirname)
   _p('else')
   _p('\t$(SILENT) mkdir $(subst /,\\\\,%s)', dirname)
   _p('endif')
   _p('')
end

--
-- Format a list of values to be safely written as part of a variable assignment.
--
function gnumake.list(value, quoted)
   quoted = false
   if #value > 0 then
      if quoted then
         local result = ""
         for _, v in ipairs (value) do
            if #result then
               result = result .. " "
            end
            result = result .. p.quoted(v)
         end
         return result
      else
         return " " .. table.concat(value, " ")
      end
   else
      return ""
   end
end

--
-- Convert an arbitrary string (project name) to a make variable name.
--
function gnumake.tovar(value)
   value = value:gsub("[ -]", "_")
   value = value:gsub("[()]", "")
   return value
end

-- Helper function-----------------------------------------------------------------------

function gnumake.phonyRules(prj)
   _p('.PHONY: clean prebuild prelink')
   _p('')
end

function gnumake.shellType()
   _p('SHELLTYPE := msdos')
   _p('ifeq (,$(ComSpec)$(COMSPEC))')
   _p('  SHELLTYPE := posix')
   _p('endif')
   _p('ifeq (/bin,$(findstring /bin,$(SHELL)))')
   _p('  SHELLTYPE := posix')
   _p('endif')
   _p('')
end

--function gnumake.outputSection(prj, callback)   
--end

function gnumake.target(cfg, toolset)
   p.outln('TARGETDIR = ' .. project.getrelative(cfg.project, cfg.buildtarget.directory))
   p.outln('TARGET = $(TARGETDIR)/' .. cfg.buildtarget.name)
end

function gnumake.objdir(cfg, toolset)
   p.outln('OBJDIR = ' .. project.getrelative(cfg.project, cfg.objdir))
end

function gnumake.targetDirRules(cfg, toolset)
   gnumake.mkdirRules("$(TARGETDIR)")
end

function gnumake.objDirRules(cfg, toolset)
   gnumake.mkdirRules("$(OBJDIR)")
end

function gnumake.preBuildRules(cfg, toolset)
    _p('prebuild:')
    _p('\t$(PREBUILDCMDS)')
    _p('')
 end

function gnumake.preLinkRules(cfg, toolset)
   _p('prelink:')
   _p('\t$(PRELINKCMDS)')
   _p('')
end

function gnumake.settings(cfg, toolset)
   if #cfg.makesettings > 0 then
      for _, value in ipairs(cfg.makesettings) do
         p.outln(value)
      end
   end

   local value = toolset.getmakesettings(cfg)
   if value then
      p.outln(value)
   end
end

function gnumake.buildCmds(cfg, event)
   _p('define %sCMDS', event:upper())

   local steps = cfg[event .. "commands"]
   local msg = cfg[event .. "message"]

   if #steps > 0 then
      steps = os.translateCommands(steps)
      msg   = msg or string.format("Running %s commands", event)

      _p('\t@echo %s', msg)
      _p('\t%s', table.implode(steps, "", "", "\n\t"))
   end

   _p('endef')
end


function gnumake.preBuildCmds(cfg, toolset)
   gnumake.buildCmds(cfg, "prebuild")
end


function gnumake.preLinkCmds(cfg, toolset)
   gnumake.buildCmds(cfg, "prelink")
end


function gnumake.postBuildCmds(cfg, toolset)
   gnumake.buildCmds(cfg, "postbuild")
end

-- Workspace ----------------------------------------------------------------------------

--
-- Generate a GNU make "workspace" makefile, with support for the new platforms API.
--
function gnumake.generateWorkspace(wks)
   p.eol("\n")

   gnumake.header(wks)

   gnumake.configmap(wks)
   gnumake.projects(wks)

   --gnumake.workspacePhonyRule(wks)
   --gnumake.groupRules(wks)

   gnumake.projectRules(wks)
   gnumake.cleanRules(wks)
   gnumake.helpRule(wks)
end

--
-- Write out the workspace's configuration map, which maps workspace
-- level configurations to the project level equivalents.
--
function gnumake.configmap(wks)
   for cfg in p.workspace.eachconfig(wks) do
      _p('ifeq ($(config),%s)', cfg.shortname)

      for prj in p.workspace.eachproject(wks) do
         local prjcfg = project.getconfig(prj, cfg.buildcfg, cfg.platform)

         if prjcfg then
            _p('  %s_config = %s', gnumake.tovar(prj.name), prjcfg.shortname)
         end
      end

      _p('endif')
   end
   _p('')
end

--
-- Write out the list of projects that comprise the workspace.
--
function gnumake.projects(wks)
   _p('PROJECTS := %s', table.concat(p.esc(table.extract(wks.projects, "name")), " "))
   _p('')
end

--
-- Write out the workspace PHONY rule
--
function gnumake.workspacePhonyRule(wks)
   local groups = {}
   local tr = p.workspace.grouptree(wks)

   print(debug.traceback())

   tree.traverse(tr, {
      onbranch = function(n)
         table.insert(groups, n.path)
      end
   })

   _p('.PHONY: all clean help $(PROJECTS) ' .. table.implode(groups, '', '', ' '))
   _p('')
   _p('all: $(PROJECTS)')
   _p('')
end

--
-- Write out the phony rules representing project groups
--
function gnumake.groupRules(wks)
   -- Transform workspace groups into target aggregate
   local tr = p.workspace.grouptree(wks)

   tree.traverse(tr, {
      onbranch = function(n)
         local rule = n.path .. ":"
         local projectTargets = {}
         local groupTargets = {}

         for i, c in pairs(n.children) do
            if type(i) == "string" then
               if c.project then
                  table.insert(projectTargets, c.name)
               else
                  table.insert(groupTargets, c.path)
               end
            end
         end
         if #groupTargets > 0 then
            rule = rule .. " " .. table.concat(groupTargets, " ")
         end
         if #projectTargets > 0 then
            rule = rule .. " " .. table.concat(projectTargets, " ")
         end
         _p(rule)
         _p('')
      end
   })
end

--
-- Write out the rules to build each of the workspace's projects.
--
function gnumake.projectRules(wks)
   for prj in p.workspace.eachproject(wks) do
      local deps = project.getdependencies(prj)

      deps = table.extract(deps, "name")
      _p('%s:%s', p.esc(prj.name), gnumake.list(deps))

      local cfgvar = gnumake.tovar(prj.name)
      _p('ifneq (,$(%s_config))', cfgvar)

      _p(1,'@echo "==== Building %s ($(%s_config)) ===="', prj.name, cfgvar)

      local prjpath = p.filename(prj, gnumake.getMakefileName(prj, true))
      local prjdir  = path.getdirectory(path.getrelative(wks.location, prjpath))
      local prjname = path.getname(prjpath)

      _x(1,'@${MAKE} --no-print-directory -C %s -f %s config=$(%s_config)', prjdir, prjname, cfgvar)

      _p('endif')
      _p('')
   end
end

--
-- Write out the rules for the `make clean` action.
--
function gnumake.cleanRules(wks)
   _p('clean:')

   for prj in p.workspace.eachproject(wks) do
      local prjpath = p.filename(prj, gnumake.getMakefileName(prj, true))
      local prjdir  = path.getdirectory(path.getrelative(wks.location, prjpath))
      local prjname = path.getname(prjpath)

      _x(1,'@${MAKE} --no-print-directory -C %s -f %s clean', prjdir, prjname)
   end

   _p('')
end

--
-- Write out the make file help rule and configurations list.
--
function gnumake.helpRule(wks)
   _p('help:')
   _p(1,'@echo "Usage: make [config=name] [target]"')
   _p(1,'@echo ""')
   _p(1,'@echo "CONFIGURATIONS:"')

   for cfg in p.workspace.eachconfig(wks) do
      _x(1, '@echo "  %s"', cfg.shortname)
   end

   _p(1,'@echo ""')

   _p(1,'@echo "TARGETS:"')
   _p(1,'@echo "   all (default)"')
   _p(1,'@echo "   clean"')

   for prj in p.workspace.eachproject(wks) do
      _p(1,'@echo "   %s"', prj.name)
   end

   _p(1,'@echo ""')
   _p(1,'@echo "For more information, see http://industriousone.com/premake/quick-start"')
end

-- CPP ----------------------------------------------------------------------------------

---
-- Add namespace for element definition lists for premake.callarray()
---
cpp.elements = {}

--
-- Generate a GNU make C++ project makefile, with support for the new platforms API.
--
cpp.elements.makefile = function(prj)
   return {
      gnumake.header,
      gnumake.phonyRules,
      gnumake.shellType,
      cpp.outputConfigurationSection,
      cpp.outputObjectsSection,
      cpp.outputFilesSection,
      cpp.outputRulesSection,
      cpp.outputFileRuleSection,
      cpp.dependencies,
   }
end

function cpp.initialize()
   rule "cxx"
      --fileExtension {".cc", ".cpp", ".cxx", ".mm"}
      buildoutputs  {'$(OBJDIR)/%{file.objname}.o'}
      buildmessage  '$(notdir $<)'
      buildcommands {'$(CXX) $(%{premake.gnumake.cpp.fileFlags(cfg, file)}) $(FORCE_INCLUDE) -o "$@" -c "$<"'}

   rule "cc"
      --fileExtension {".c", ".s", ".m"}
      buildoutputs  {'$(OBJDIR)/%{file.objname}.o'}
      buildmessage  '$(notdir $<)'
      buildcommands {'$(CC) $(%{premake.gnumake.cpp.fileFlags(cfg, file)}) $(FORCE_INCLUDE) -o "$@" -c "$<"'}

   rule "resource"
      buildoutputs  {'$(OBJDIR)/%{file.objname}.res'}
      buildmessage  '$(notdir $<)'
      buildcommands {'$(RESCOMP) $< -O coff -o "$@" $(ALL_RESFLAGS)'}

   global(nil)
end

function cpp.generate(prj)
   -- create fileset categories.
   local filesets = {
      ['.o']   = 'OBJECTS',
      ['.obj'] = 'OBJECTS',
      ['.cc']  = 'SOURCES',
      ['.cpp'] = 'SOURCES',
      ['.cxx'] = 'SOURCES',
      ['.mm']  = 'SOURCES',
      ['.c']   = 'SOURCES',
      ['.s']   = 'SOURCES',
      ['.m']   = 'SOURCES',
      ['.rc']  = 'RESOURCES',
   }
   
   -- cache the result.
   prj._gnumake = prj._gnumake or {}
   prj._gnumake.filesets = filesets

   p.eol("\n")
   p.callArray(cpp.elements.makefile, prj)

   -- allow the garbage collector to clean things up.
   for cfg in project.eachconfig(prj) do
      cfg._gnumake = nil
   end
   prj._gnumake = nil
end

function cpp.getRuleForFileName(fname)

   if path.iscfile(fname) then
      return p.global.getRule("cc")
   elseif path.iscppfile(fname) then
      return p.global.getRule("cxx")
   elseif path.isresourcefile(fname) then
      return p.global.getRule("resource")
   end

   return nil   
end

function cpp.outputObjectsSection(prj)
   local fileRules = {}

   local files = table.shallowcopy(prj._.files)

   for cfg in project.eachconfig(prj) do
     
      for _, node in ipairs(files) do
         local filecfg = fileconfig.getconfig(node, cfg)

         if filecfg and not filecfg.flags.ExcludeFromBuild then
             cpp.addFile(fileRules, node)
         end
      end

   end
end

function cpp.addFile(fileRules, node)
   local rule = cpp.getRuleForFileName(node.abspath)

   if not rule then
      return
   end

   local filesets = project._gnumake.filesets
   local kind     = filesets[path.getextension(node.abspath)]
   if kind then
      local fileset = cfg._gmake.filesets[kind] or {}
      table.insert(fileset, filename)
      cfg._gmake.filesets[kind] = fileset
   end

   -- identify the file type

   --fileRules['OBJECTS']

   -- skip files that aren't compiled

   -- assign a unique object file name to avoid collisions

   --local file = {
   --   buildoutputs  = rule.buildoutputs,
   --   source        = rule.node.relpath,
   --   buildmessage  = rule.buildmessage,
   --   buildcommands = rule.buildcommands,
   --   buildinputs   = rule.buildinputs
   --}
   --table.insert(fileRules, file)

   

end

function cpp.outputObjectsSection2(prj)
   -- create lists for intermediate files, at the project level and
   -- for each configuration
   local root = { objects={}, resources={}, customfiles={} }
   local configs = {}
   for cfg in project.eachconfig(prj) do
      configs[cfg] = { objects={}, resources={}, customfiles={} }
   end

   -- now walk the list of files in the project
   local tr = project.getsourcetree(prj)
   premake.tree.traverse(tr, {
      onleaf = function(node, depth)
         -- figure out what configurations contain this file, and
         -- if it uses custom build rules
         local incfg = {}
         local inall = true
         local custom = false
         for cfg in project.eachconfig(prj) do
            local filecfg = fileconfig.getconfig(node, cfg)
            if filecfg and not filecfg.flags.ExcludeFromBuild then
               incfg[cfg] = filecfg
               custom = fileconfig.hasCustomBuildRule(filecfg)
            else
               inall = false
            end
         end

         if not custom then
            -- identify the file type
            local kind
            if path.iscppfile(node.abspath) then
               kind = "objects"
            elseif path.isresourcefile(node.abspath) then
               kind = "resources"
            end

            -- skip files that aren't compiled
            if not custom and not kind then
               return
            end

            -- assign a unique object file name to avoid collisions
            objectname = "$(OBJDIR)/" .. node.objname .. iif(kind == "objects", ".o", ".res")

            -- if this file exists in all configurations, write it to
            -- the project's list of files, else add to specific cfgs
            if inall then
               table.insert(root[kind], objectname)
            else
               for cfg in project.eachconfig(prj) do
                  if incfg[cfg] then
                     table.insert(configs[cfg][kind], objectname)
                  end
               end
            end

         else
            for cfg in project.eachconfig(prj) do
               local filecfg = incfg[cfg]
               if filecfg then
                  -- if the custom build outputs an object file, add it to
                  -- the link step automatically to match Visual Studio
                  local output = project.getrelative(prj, filecfg.buildoutputs[1])
                  if path.isobjectfile(output) then
                     table.insert(configs[cfg].objects, output)
                  else
                     table.insert(configs[cfg].customfiles, output)
                  end
               end
            end
         end

      end
   })

   -- now I can write out the lists, project level first...
   function listobjects(var, list)
      _p('%s \\', var)
      for _, objectname in ipairs(list) do
         _x('\t%s \\', objectname)
      end
      _p('')
   end

   listobjects('OBJECTS :=', root.objects, 'o')
   listobjects('RESOURCES :=', root.resources, 'res')
   listobjects('CUSTOMFILES :=', root.customfiles)

   -- ...then individual configurations, as needed
   for cfg in project.eachconfig(prj) do
      local files = configs[cfg]
      if #files.objects > 0 or #files.resources > 0 or #files.customfiles > 0 then
         _x('ifeq ($(config),%s)', cfg.shortname)
         if #files.objects > 0 then
            listobjects('  OBJECTS +=', files.objects)
         end
         if #files.resources > 0 then
            listobjects('  RESOURCES +=', files.resources)
         end
         if #files.customfiles > 0 then
            listobjects('  CUSTOMFILES +=', files.customfiles)
         end
         _p('endif')
         _p('')
      end
   end
end

--
-- C++ Files Section --------------------------------------------------------------------
--

function cpp.outputFilesSection(prj)
   _p('# File sets')
   _p('# #############################################')
   _p('')
end

--
-- C++ Rules Section --------------------------------------------------------------------
--

cpp.elements.rules = function(cfg, toolset)
   return {
      cpp.allRules,
      cpp.targetRules,
      gnumake.targetDirRules,
      gnumake.objDirRules,
      cpp.cleanRules,
      gnumake.preBuildRules,
      gnumake.preLinkRules,
      cpp.pchRules,
   }
end

function cpp.outputRulesSection(prj)
   _p('# Rules')
   _p('# #############################################')
   _p('')

   --make.outputSection(prj, cpp.elements.rules)
   
   local cfg = project.getfirstconfig(prj)
   -- identify the toolset used by this configurations (would be nicer if
   -- this were computed and stored with the configuration up front)
   local toolset = premake.tools[_OPTIONS.cc or cfg.toolset or "gcc"]

   if not toolset then
      error("Invalid toolset '" .. cfg.toolset .. "'")
   end

   p.callArray(cpp.elements.rules, cfg, toolset)
end

function cpp.allRules(cfg, toolset)
   if cfg.system == p.MACOSX and cfg.kind == p.WINDOWEDAPP then
      _p('all: $(TARGETDIR) $(OBJDIR) prebuild prelink $(TARGET) $(dir $(TARGETDIR))PkgInfo $(dir $(TARGETDIR))Info.plist')
      _p('\t@:')
      _p('')
      _p('$(dir $(TARGETDIR))PkgInfo:')
      _p('$(dir $(TARGETDIR))Info.plist:')
   else
      _p('all: $(TARGETDIR) $(OBJDIR) prebuild prelink $(TARGET)')
      _p('\t@:')
   end
   _p('')
end


function cpp.targetRules(cfg, toolset)
   _p('$(TARGET): $(GCH) ${CUSTOMFILES} $(OBJECTS) $(LDDEPS) $(RESOURCES)')
   _p('\t@echo Linking %s', cfg.project.name)
   _p('\t$(SILENT) $(LINKCMD)')
   _p('\t$(POSTBUILDCMDS)')
   _p('')
end

function cpp.cleanRules(cfg, toolset)
   _p('clean:')
   _p('\t@echo Cleaning %s', cfg.project.name)
   _p('ifeq (posix,$(SHELLTYPE))')
   _p('\t$(SILENT) rm -f  $(TARGET)')
   _p('\t$(SILENT) rm -rf $(OBJDIR)')
   _p('else')
   _p('\t$(SILENT) if exist $(subst /,\\\\,$(TARGET)) del $(subst /,\\\\,$(TARGET))')
   _p('\t$(SILENT) if exist $(subst /,\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\,$(OBJDIR))')
   _p('endif')
   _p('')
end

function cpp.pchRules(cfg, toolset)
   _p('ifneq (,$(PCH))')
   _p('$(OBJECTS): $(GCH) $(PCH)')
   _p('$(GCH): $(PCH)')
   _p('\t@echo $(notdir $<)')

   local cmd = iif(cfg.language == "C", "$(CC) -x c-header $(ALL_CFLAGS)", "$(CXX) -x c++-header $(ALL_CXXFLAGS)")
   _p('\t$(SILENT) %s -o "$@"  -c "$<"', cmd)
   _p('endif')
   _p('')
end

--
-- C++ File Rule Section ----------------------------------------------------------------
--

function cpp.outputFileRuleSection(prj)
   _p('# File Rules')
   _p('# #############################################')
   _p('')
   --make.outputSection(prj, cpp.elements.fileRules)

   
   --for k, v in pairs(prj._gnumake.filesets) do
   --   print("key: ", k, "value: ", v)
   --end

   
   for cfg in project.eachconfig(prj) do

      local files = table.shallowcopy(prj._.files)
      table.foreachi(files, function(node)
         --cpp.addFile(cfg, node)
         --print(node.abspath)
         --print(node.name)
         --for k, v in pairs(node) do
         --   print("key: ", k, "value: ", v)
         --end
      end)

      --for _, f in pairs(cfg._gmake.filesets) do
      --   table.sort(f)
      --end
--
      --cfg._gmake.kinds = table.keys(cfg._gmake.filesets)
      --table.sort(cfg._gmake.kinds)
--
      --prj._gmake.kinds = table.join(prj._gmake.kinds or {}, cfg._gmake.kinds)
   end

   --local tr = project.getsourcetree(prj)
   --premake.tree.traverse(tr, {
   --   onleaf = function(node, depth)
   --      -- check to see if this file has custom rules
   --      local rules
   --      for cfg in project.eachconfig(prj) do
   --         local filecfg = fileconfig.getconfig(node, cfg)
   --         if fileconfig.hasCustomBuildRule(filecfg) then
   --            rules = true
   --            break
   --         end
   --      end
--
   --      -- if it has custom rules, need to break them out
   --      -- into individual configurations
   --      if rules then
   --         cpp.customFileRules(prj, node)
   --      else
   --         cpp.standardFileRules(prj, node)
   --      end
   --   end
   --})
   --_p('')
end

function cpp.standardFileRules(prj, node)
   -- C/C++ file
   if path.iscppfile(node.abspath) then
      _x('$(OBJDIR)/%s.o: %s', node.objname, node.relpath)
      _p('\t@echo $(notdir $<)')
      --cpp.buildcommand(prj, "o", node)

      local rule = premake.global.getRule("cpp")
      print(rule.buildcommands)

   -- resource file
   elseif path.isresourcefile(node.abspath) then
      _x('$(OBJDIR)/%s.res: %s', node.objname, node.relpath)
      _p('\t@echo $(notdir $<)')
      _p('\t$(SILENT) $(RESCOMP) $< -O coff -o "$@" $(ALL_RESFLAGS)')
   end
end

function cpp.customFileRules(prj, node)
   for cfg in project.eachconfig(prj) do
      local filecfg = fileconfig.getconfig(node, cfg)
      if filecfg then
         _x('ifeq ($(config),%s)', cfg.shortname)

         local output = project.getrelative(prj, filecfg.buildoutputs[1])
         local dependencies = filecfg.relpath
         if filecfg.buildinputs and #filecfg.buildinputs > 0 then
            local inputs = project.getrelative(prj, filecfg.buildinputs)
            dependencies = dependencies .. " " .. table.concat(p.esc(inputs), " ")
         end
         _p('%s: %s', output, dependencies)
         _p('\t@echo "%s"', filecfg.buildmessage or ("Building " .. filecfg.relpath))

         local cmds = os.translateCommands(filecfg.buildcommands)
         for _, cmd in ipairs(cmds) do
            if cfg.bindirs and #cfg.bindirs > 0 then
               _p('\t$(SILENT) $(EXE_PATHS) %s', cmd)
            else
               _p('\t$(SILENT) %s', cmd)
            end
         end
         _p('endif')
      end
   end
end

--
-- C++ Dependencies Section ----------------------------------------------------------------
--

function cpp.dependencies(prj)
   -- include the dependencies, built by GCC (with the -MMD flag)
   _p('-include $(OBJECTS:%%.o=%%.d)')
   _p('ifneq (,$(PCH))')
   _p('  -include $(OBJDIR)/$(notdir $(PCH)).d')
   _p('endif')
end

--
-- Write out the settings for a particular configuration.
--
cpp.elements.configuration = function(cfg)
   return {
      cpp.tools,
      gnumake.target,
      gnumake.objdir,
      cpp.pch,
      cpp.defines,
      cpp.includes,
      cpp.forceInclude,
      cpp.cppFlags,
      cpp.cFlags,
      cpp.cxxFlags,
      cpp.resFlags,
      cpp.libs,
      cpp.ldDeps,
      cpp.ldFlags,
      cpp.linkCmd,
      cpp.bindirs,
      cpp.exepaths,
      cpp.ruleProperties,
      gnumake.settings,
      gnumake.preBuildCmds,
      gnumake.preLinkCmds,
      gnumake.postBuildCmds,
   }
end

function cpp.outputConfigurationSection(prj)
   _p('# Configurations')
   _p('# #############################################')
   _p('')
   
   --gnumake.outputSection(prj, cpp.elements.configuration)

   for cfg in project.eachconfig(prj) do
      -- identify the toolset used by this configurations (would be nicer if
      -- this were computed and stored with the configuration up front)

      local toolset = premake.tools[_OPTIONS.cc or cfg.toolset or "gcc"]
      if not toolset then
         error("Invalid toolset '" .. cfg.toolset .. "'")
      end

      _x('ifeq ($(config),%s)', cfg.shortname)
      premake.callArray(cpp.elements.configuration, cfg, toolset)
      _p('endif')
      _p('')
   end

end

function cpp.tools(cfg, toolset)
   local tool = toolset.gettoolname(cfg, "cc")
   if tool then
      _p('ifeq ($(origin CC), default)')
      _p('  CC = %s', tool)
      _p('endif' )
   end

   tool = toolset.gettoolname(cfg, "cxx")
   if tool then
      _p('ifeq ($(origin CXX), default)')
      _p('  CXX = %s', tool)
      _p('endif' )
   end

   tool = toolset.gettoolname(cfg, "ar")
   if tool then
      _p('ifeq ($(origin AR), default)')
      _p('  AR = %s', tool)
      _p('endif' )
   end

   tool = toolset.gettoolname(cfg, "rc")
   if tool then
      _p('RESCOMP = %s', tool)
   end
end

function cpp.pch(cfg, toolset)
   -- If there is no header, or if PCH has been disabled, I can early out
   if not cfg.pchheader or cfg.flags.NoPCH then
      return
   end

   -- Visual Studio requires the PCH header to be specified in the same way
   -- it appears in the #include statements used in the source code; the PCH
   -- source actual handles the compilation of the header. GCC compiles the
   -- header file directly, and needs the file's actual file system path in
   -- order to locate it.

   -- To maximize the compatibility between the two approaches, see if I can
   -- locate the specified PCH header on one of the include file search paths
   -- and, if so, adjust the path automatically so the user doesn't have
   -- add a conditional configuration to the project script.

   local pch = cfg.pchheader
   local found = false

   -- test locally in the project folder first (this is the most likely location)
   local testname = path.join(cfg.project.basedir, pch)
   if os.isfile(testname) then
      pch = project.getrelative(cfg.project, testname)
      found = true
   else
      -- else scan in all include dirs.
      for _, incdir in ipairs(cfg.includedirs) do
         testname = path.join(incdir, pch)
         if os.isfile(testname) then
            pch = project.getrelative(cfg.project, testname)
            found = true
            break
         end
      end
   end

   if not found then
      pch = project.getrelative(cfg.project, path.getabsolute(pch))
   end

   p.outln('PCH = ' .. pch)
   p.outln('GCH = $(OBJDIR)/$(notdir $(PCH)).gch')
end

function cpp.defines(cfg, toolset)
   _p('DEFINES +=%s', gnumake.list(table.join(toolset.getdefines(cfg.defines, cfg), toolset.getundefines(cfg.undefines))))
end

function cpp.includes(cfg, toolset)
   local includes = toolset.getincludedirs(cfg, cfg.includedirs, cfg.sysincludedirs)
   _p('INCLUDES +=%s', gnumake.list(includes))
end

function cpp.forceInclude(cfg, toolset)
   local includes = toolset.getforceincludes(cfg)
   if not cfg.flags.NoPCH and cfg.pchheader then
      table.insert(includes, "-include $(OBJDIR)/$(notdir $(PCH))")
   end
   p.outln('FORCE_INCLUDE +=' .. gnumake.list(includes))
end

function cpp.cppFlags(cfg, toolset)
   local flags = gnumake.list(toolset.getcppflags(cfg))
   p.outln('ALL_CPPFLAGS += $(CPPFLAGS)' .. flags .. ' $(DEFINES) $(INCLUDES)')
end


function cpp.cFlags(cfg, toolset)
   local flags = gnumake.list(table.join(toolset.getcflags(cfg), cfg.buildoptions))
   p.outln('ALL_CFLAGS += $(CFLAGS) $(ALL_CPPFLAGS)' .. flags)
end


function cpp.cxxFlags(cfg, toolset)
   local flags = gnumake.list(toolset.getcxxflags(cfg))
   p.outln('ALL_CXXFLAGS += $(CXXFLAGS) $(ALL_CFLAGS)' .. flags)
end

function cpp.resFlags(cfg, toolset)
   local resflags = table.join(toolset.getdefines(cfg.resdefines), toolset.getincludedirs(cfg, cfg.resincludedirs), cfg.resoptions)
   p.outln('ALL_RESFLAGS += $(RESFLAGS) $(DEFINES) $(INCLUDES)' .. gnumake.list(resflags))
end


function cpp.libs(cfg, toolset)
   local flags = toolset.getlinks(cfg)
   p.outln('LIBS +=' .. gnumake.list(flags, true))
end


function cpp.ldDeps(cfg, toolset)
   local deps = config.getlinks(cfg, "siblings", "fullpath")
   p.outln('LDDEPS +=' .. gnumake.list(p.esc(deps)))
end


function cpp.ldFlags(cfg, toolset)
   local flags = table.join(toolset.getLibraryDirectories(cfg), toolset.getrunpathdirs(cfg, cfg.runpathdirs), toolset.getldflags(cfg), cfg.linkoptions)
   p.outln('ALL_LDFLAGS += $(LDFLAGS)' .. gnumake.list(flags))
end

function cpp.linkCmd(cfg, toolset)
   if cfg.kind == p.STATICLIB then
      if cfg.architecture == p.UNIVERSAL then
         p.outln('LINKCMD = libtool -o "$@" $(OBJECTS)')
      else
         p.outln('LINKCMD = $(AR) -rcs "$@" $(OBJECTS)')
      end
   elseif cfg.kind == p.UTILITY then
      -- Empty LINKCMD for Utility (only custom build rules)
      p.outln('LINKCMD =')
   else
      -- this was $(TARGET) $(LDFLAGS) $(OBJECTS)
      --   but had trouble linking to certain static libs; $(OBJECTS) moved up
      -- $(LDFLAGS) moved to end (http://sourceforge.net/p/premake/patches/107/)
      -- $(LIBS) moved to end (http://sourceforge.net/p/premake/bugs/279/)

      local cc = iif(cfg.language == "C", "CC", "CXX")
      p.outln('LINKCMD = $(' .. cc .. ') -o "$@" $(OBJECTS) $(RESOURCES) -link $(ALL_LDFLAGS) $(LDDEPS) $(LIBS)')
   end
end

function cpp.bindirs(cfg, toolset)
   local dirs = project.getrelative(cfg.project, cfg.bindirs)
   if #dirs > 0 then
      p.outln('EXECUTABLE_PATHS = "' .. table.concat(dirs, ":") .. '"')
   end
end


function cpp.exepaths(cfg, toolset)
   local dirs = project.getrelative(cfg.project, cfg.bindirs)
   if #dirs > 0 then
      p.outln('EXE_PATHS = export PATH=$(EXECUTABLE_PATHS):$$PATH;')
   end
end

function cpp.ruleProperties(cfg, toolset)
   for i = 1, #cfg.rules do
      local rule = p.global.getRule(cfg.rules[i])

      for prop in p.rule.eachProperty(rule) do
         local fld = p.rule.getPropertyField(rule, prop)
         local value = cfg[fld.name]
         if value ~= nil then
            if fld.kind == "path" then
               value = make.path(cfg, value)
            elseif fld.kind == "list:path" then
               value = make.path(cfg, value)
            end

            value = p.rule.expandString(rule, prop, value)
            if value ~= nil and #value > 0 then
               p.outln(prop.name .. ' = ' .. p.esc(value))
            end
         end
      end
   end
end

return gnumake